
+++
title = "NumPy中的线性代数"
summary = ''
description = ""
categories = []
tags = []
date = 2016-05-25T06:39:58+08:00
draft = false
+++

## 矩阵基本运算
### 创建矩阵

    # 行与行之间用分号隔开，行内的元素之间用空格隔开
    >>> m = matrix('1 2 3;4 5 6;7 8 9')
    >>> m
    matrix([[1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]])

### 矩阵转置

    # 使用 transpose 来获取转置矩阵
    >>> transpose(m)
    matrix([[1, 4, 7],
            [2, 5, 8],
            [3, 6, 9]])
    # 使用 T 属性获取转置矩阵
    >>> m.T
    matrix([[1, 4, 7],
            [2, 5, 8],
            [3, 6, 9]])

### 逆矩阵

    # inv
    >>> m = matrix('1 1 2;-1 2 0;1 1 3')
    >>> linalg.inv(m)
    matrix([[ 2.        , -0.33333333, -1.33333333],
            [ 1.        ,  0.33333333, -0.66666667],
            [-1.        ,  0.        ,  1.        ]])

    # I
    >>> m = matrix('1 1 2;-1 2 0;1 1 3')
    >>> m.I
    matrix([[ 2.        , -0.33333333, -1.33333333],
            [ 1.        ,  0.33333333, -0.66666667],
            [-1.        ,  0.        ,  1.        ]])


### 分块矩阵

    >>> a = eye(2)
    >>> b = a * 2
    >>> bmat('a b;a b')
    matrix([[ 1.,  0.,  2.,  0.],
            [ 0.,  1.,  0.,  2.],
            [ 1.,  0.,  2.,  0.],
            [ 0.,  1.,  0.,  2.]])

### 斐波那契数列
斐波那契数列的计算等价于矩阵的连乘

    #计算斐波那契数列中的第8个数
    >>> x = 8
    >>> (matrix('1 1;1 0') ** (x-1))[0,0]
    21

使用binet公式计算斐波那契数列

    >>> sqrt5 = sqrt(5)
    >>> phi = (1+sqrt5)/2
    >>> rint((phi**x - (-1/phi)**x)/sqrt5)
    21.0


## 线性代数
numpy.linalg模块包含线性代数函数
### 求解 Ax=b 的线性方程组

    # 1x-2y+z=0
    # 2y-8z=8
    # -4x+5y+9z=-9

    >>> A = matrix('1 -2 1;0 2 -8;-4 5 9')
    >>> b = array([0,8,-9])
    >>> x = linalg.solve(A,b)
    >>> print x
    [ 29.  16.   3.]

    >>> print dot(A,x)
    [[ 0.  8. -9.]]

### 特征值和特征向量
设A为n阶矩阵，若存在常数λ及n维非零向量x，使得Ax=λx，则称λ是矩阵A的特征值，x是A属于特征值λ的特征向量

    >>> a = matrix('-1 1 0;-4 3 0;1 0 2')
    # eigvals()返回特征值
    >>> linalg.eigvals(a)
    array([ 2.,  1.,  1.])
    # eig()返回一个元组,第一项为特征值，第二项为对应的特征向量(按列排放)
    >>> linalg.eig(a)
    (array([ 2.,  1.,  1.]), matrix([[ 0.        ,  0.40824829,  0.40824829],
            [ 0.        ,  0.81649658,  0.81649658],
            [ 1.        , -0.40824829, -0.40824829]]))

    #2  [0,0,1]
    #1  [0.40824829,0.81649658,-0.40824829]
    #验证
    >>> dot(a,[0,0,1])
    matrix([[0, 0, 2]])
    >>> dot(2,[0,0,1])
    array([0, 0, 2])
    >>> dot(a,[0.40824829,0.81649658,-0.40824829])
    matrix([[ 0.40824829,  0.81649658, -0.40824829]])
    >>> dot(1,[0.40824829,0.81649658,-0.40824829])
    array([ 0.40824829,  0.81649658, -0.40824829])

### 奇异值分解
[奇异值分解](https://zh.wikipedia.org/zh/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3)

    >>> m = matrix('4 11 14;8 7 -2')
    >>> U,Sigma,V = linalg.svd(m)
    >>> print Sigma
    [ 18.97366596   9.48683298]

### 广义逆矩阵
[摩尔－彭若斯广义逆](https://zh.wikipedia.org/zh/%E6%91%A9%E5%B0%94%EF%BC%8D%E5%BD%AD%E8%8B%A5%E6%96%AF%E5%B9%BF%E4%B9%89%E9%80%86)

    >>> m = matrix('4 11 14;8 7 -2')
    >>> n = linalg.pinv(m)
    >>> print m*n
    [[  1.00000000e+00  -5.41233725e-16]
     [ -8.32667268e-17   1.00000000e+00]]
    #近似单位阵

### 行列式计算

    >>> m = matrix('4 6;8 2')
    >>> linalg.det(m)
    -40.0

